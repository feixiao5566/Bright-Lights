#!/usr/bin/env python
# encoding: utf-8

#正则表达式是一种用来匹配字符串的强有力的武器.它的思想是用一种描述性的
#语言来给字符串定义一个规则,凡是符合规则的字符串,我们就认为它'匹配'了,
#否则该字符串就是不合法的.

#所以我们判断一个字符串是否是合法的Email的方法是:
# 1.创建一个匹配Email的正则表达式
# 2.用该正则表达式去匹配用户的输入来判断是否合法

#如何用字符来描述字符
#在正则表达式中,如果直接给出字符,就是精确匹配.用\d可以匹配一个数字,
# \w可以匹配一个字母或数字,所以:
# '00\d' 可以匹配'007', 但无法匹配'00A'
# '\d\d\d'可以匹配 '010'
# '\w\w\d'可以匹配'py3'

# .可以匹配任何字符,所以:
#       'py.'可以匹配'pyc' 'pyo' 'py!'等

#要匹配变长的字符,在正则表达式中,用*表示任意个字符(包括0个),用 + 表示
#至少一个字符,用 ? 表示0个或1个字符,用{n}表示n个字符,用{n, m}表示n-m个字符

#栗子:
#     \d{3}\s+\d{3,8}
#表示有3个数字,数个空格(包括Tab等空白符), 3~8个数字

#另一个栗子:
#     '010-12345'
#由于'-'是特殊字符,在正则表达式中,要用'\'转义,所以这句的正则表达是:
#     \d{3}\-\d{3,8}


###进阶###
#要做更精确的匹配,可以用[]表示范围,如:
# · [0-9a-zA-Z\_]可以匹配一个数字 字母或者下划线
# · [0-9a-zA-Z\_]+可以匹配至少由一个数字 字母或者下划线组成的字符串,如
#   'a100', '0_Z', 'Py3000'等等
# · [a-zA-Z\_]{0-9a-zA-Z\_]*可以匹配字母或下划线开头,后接任意个由一个数字
#   字母或者下划线组成的字符串, 也就是Python的合法变量
# · [a-zA-Z\_][0-9a-zA-Z\_]{0,19}更精确的限制了变量的长度是1-20个字符
#   (前面1个字符+后面最多19个字符)

#  A|B可以匹配A或B,所以[P|p]ython可以匹配'Python'
#  ^表示行的开头, ^\d表示必须以数字开头
#  $表示行的结束, \d$表示必须以数字结束
#所以,py也可以匹配'python', 但是加上^py$就编程了整行匹配,就只能匹配'py'了


##re模块
#re模块包含所有的正则表达式的功能.要注意py字符串本身也用\转义
#譬如: s = 'ABC\\-001'  python的字符串
#正则表达式就变成了 'ABC\-001'

#因此,为解决这个矛盾,在字符串前面加上前缀 r ,就不考虑转义的问题了;
#譬如: s = r'ABC\-001'  python的字符串
#对应的正则表达式字符串不变:
#'ABC\-001'

#如何判断正则表达式是否匹配:
import re
test='用户输入的字符串'
if re.match(r'正则表达式', test):
    print('ok')
else:
    print('failed')






