#include<stdio.h>
struct test
{
    char f1:3;
    short f2:4;
    char f3:5;
};
//求sizeof(test)大小
void main()
{
    int a = 0;
    struct test t;
    a = sizeof(t);
    printf("%d\n", a);
}

/*
 *4
 想的是f2会从第4个
 * */

/*位域:
 *含位域结构体
 *1)如果相邻位域字段的类型相同,且其位宽之和小于类型的sizeof大小,
    则后面的字段将紧邻前一个字段存储,直到不能容纳为止
 *2)如果相邻位域中字段的类型相同,但其位宽之和大于类型的sizeof大小.
    则后面的字段将从新的存储单元开始,其偏移量为其类型大小的整数倍
 *3)如果相邻的位域字段的类型不同,则各编译器的具体实现有差异,
    VC6采取不压缩,Dev-C++采取压缩方式
 *4)如果位域字段之间穿插着非位域字段,则不进行压缩
 *5)整个结构体的总大小为最宽基本类型成员大小的整数倍
 * */
